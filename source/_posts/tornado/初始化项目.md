---
title: 初始化 tornado 项目
date: 2019-06-27 14:20:24
tags: tornado
category: tornado
---
初始化 `tornado` 项目
<!-- more -->
# 项目结构
```
tornado-blog
  ---blog
   -- index 
   	- __init__.py
   	- handlers.py  : 存放处理请求的逻辑函数
   -- auth 
   -- statics	   ：存放静态 css 文件
   -- templates	   ：存放 html 模板
   routes.py       ：存放 url
   models.py       ：ORM 数据库 
   __init__.py     : 创建 app
  ---venv
  config.py        : 配置文件分离 
  server.py        ：启动服务
```

# 配置文件
```py
# coding: utf-8 
# config.py 
# this is configuration for tornado project 

import os
class Config:
    DB_URL = "mysql://root:qwe123@127.0.0.1/blog"
    PORT = 8000
    TEMPLATES = os.path.join(os.path.dirname(__file__),"blog","templates")
    STATICS = os.path.join(os.path.dirname(__file__),"blog","statics")

class DevConfig(Config):
    DEBUG = True
    

class ProdConfig(Config):
    DEBUG = False

Configuration = {
    "dev":DevConfig
}
```
# 新建 app
```py
# coding: utf-8 
import os 
from blog.routes import urls
from tornado.web import Application
from tornado.options import options,define
from tornado_sqlalchemy import make_session_factory
from config import Configuration

def config_from_object(obj):
    config = {}
    for key in dir(obj):
        if key.isupper():
            config[key] = getattr(obj, key)
    
    return config

def create_app(config_name):
    # 数据库配置
    configs = config_from_object(Configuration[config_name])
    db_url = configs.get('DB_URL')
    port = configs['PORT'] 
    debug = configs['DEBUG']
    template_path = configs.get('TEMPLATES')
    static_path = configs.get('STATICS')

    session_factory = make_session_factory(db_url)
    settings = dict(
        template_path = template_path,
        static_path = static_path,
        debug = debug,
        session_factory=session_factory
    )

    app = Application(
        handlers= urls,
        **settings
    ).listen(port)

    print("server start on {}".format(port))
    print("Quit the server with Control+C")
```

# 启动 server 配置
```py
'''
tornado.httpserver：这个模块就是用来解决 web 服务器的 http 协议问题，它提供了不少属性方法，实现客户端和服务器端的互通。Tornado 的非阻塞、单线程的特点在这个模块中体现。
tornado.ioloop：这个也非常重要，能够实现非阻塞 socket 循环，不能互通一次就结束呀。
tornado.options：这是命令行解析模块，也常用到。
tornado.web：这是必不可少的模块，它提供了一个简单的 Web 框架与异步功能，从而使其扩展到大量打开的连接，使其成为理想的长轮询。
'''
from tornado import httpserver
from tornado.ioloop import IOLoop
from blog import create_app



if __name__ == "__main__":
    app = create_app('dev')
    http_server = httpserver.HTTPServer(app)
    IOLoop.instance().start()
```

# 简单测试

配置 `routes.py` 和 `index/handlers.py` 进行测试
```py
# coding: utf-8 
# routes.py 
# this is urls setting for this project

from .index.handlers import IndexRequestHandler
from tornado.web import url
urls = [
   url(r'/',IndexRequestHandler,name="index")
]
```
配置请求
```py
# coding: utf-8
# index.handlers.py
# this file is for handle all index model's requests 

from tornado.web import RequestHandler

class IndexRequestHandler(RequestHandler):

    def get(self):
        self.write("Hello tornado!")

```
打开页面 `http://127.0.0.1:8000/`
![tornado1](/postimg/tornado1.png)
