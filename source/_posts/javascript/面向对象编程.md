面向对象的语言有一个标志，就是有类的概念，通过类创建任意多个具有相同属性和方法的对象(实例)

# 理解对象

使用字面量的方式创建对象
```javascript
var person = {
    name: "John.Doe",
    age: 20,
    sayName: function(){
        console.log(this.name);
    }
}
person.sayName();
```

# 属性
## 数据属性
1. Configurable: 能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，能否将属性修改为访问器属性，默认为 true，注意一旦设置为 false，后面就不可以在配置这些属性了。
2. Enumerable： 是否能够通过 for-in 循环返回属性，默认 true
3. Writeable：表示能否修改属性的值，默认为 true 
4. Value： 这个属性的数据值，读取和写入都是对于这个值来说，默认是 undefined

```js
Object.defineProperty(person, 'name', {
    Writeable: false,
    value: "John Doe"
})

console.log(person.name);
person.name = "gary";
//无法改变
console.log(person.name); // John Doe
```
## 访问器属性
不包含数据值，包含一对 getter 和 setter 函数

# 创建对象的几种方式
## 工厂模式
```js
"use strict"

function createPerson (name,age) {
  var o = new Object();
  o.name = name;
  o.age = age;
  o.sayName = () => {
    console.log(o.name);
  }
  
  return o;
}

var p1 = createPerson("John Doe",20);
p1.sayName();
```
缺点： 没有解决对象识别的问题，所有的对象都是 Object 对象

## 构造函数
```js
function Person(name,age) {
  this.name = name;
  this.age = age;
  this.sayName = () => {
    console.log(this.name);
  }
}

var p2 = new Person("John Doa", 20);
p2.sayName();
```
特点：
1. 首字母必须要大写
2. 直接属性和方法赋值给 this 对象
3. 必须使用 new
4. 解决了对象识别的问题

缺点：每次创建实例，都会重新创建 sayName 函数，造成资源浪费

## 原型模式
一个实例这里假设为 perosn1 和 person2
他们会有一个 prototype 属性指向其原型对象
原型对象会有一个 constructor 属性指向构造函数
构造函数也是一个实例，所以也会有一个 prototype 属性指向原型对象。
所有的实例共享原型对象里面的函数和属性
从中可以看出，实例其实跟构造函数没有直接关系，而只是跟原型对象保持关系

在所有的实现中，都无法取到原型对象，但是可以通过函数 Object.getPrototypeOf(person1) 来取得实例的原型对象

```js

function Person(name){
  this.name = name
}

Person.prototype.name = "test";

var p = new Person("john");
console.log(p.name); // john

```
使用 hasOwnProperty() 方法，可以判断属性是否来自实例属性。
使用 in 可以判断是否是一个可以访问到的属性，因此 in = true 而 hasOwnProperty() = false 就可以判断是否是原型对象的属性

通过 Object.keys(obj) 也可以遍历一个对象的属性，传入什么对象就遍历那个对象，不包括原型对象。

通过改进
```js
function Person(){}
Person.prototype = {
    constructor: Person,
    ...
} 
```
但是这样做有一个缺点，就是新建实例，再定义原型对象的时候，这个时候调用原型对象的函数就会失败
```js
function Person(){}
var p = new Person();
Person.prototype = {
    constructor: Person,
    sayName:()=>{
        console.log("name");
    }
} 
p.sayName();//error
```
这是因为创建实例的时候会为实例添加一个指向最初原型的指针，暂时称为 init 原型
然后这个时候重写了原型，等于切断了构造函数跟 init 原型对象的联系，这里假设命名为 rewrite 原型
但是实例只跟原型对象有直接联系，所以这个时候，实例实际是指向 init 原型，不指向rewrite原型，所以最好重写完原型以后再创建实例对象


# 继承




